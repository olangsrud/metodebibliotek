[
  {
    "path": "posts/plsrounding/",
    "title": "PLSrounding",
    "description": "Small count rounding of necessary inner cells are performed so that all small frequencies of cross-classifications to be published (publishable cells) are rounded. The publishable cells can be defined from a model formula, hierarchies or automatically from data.",
    "author": [
      {
        "name": "SmallCountRounding",
        "url": {}
      }
    ],
    "date": "2021-12-07",
    "categories": [
      "R",
      "confidentiality"
    ],
    "contents": "\r\n\r\nContents\r\nParameters\r\nValues\r\nExamples\r\n\r\n\r\nGo to source code \r\n\r\nParameters\r\n\r\nItem\r\nDescription\r\ndata\r\nInput data as a data frame (inner cells)\r\nfreqVar\r\nVariable holding counts (inner cells frequencies). When ‘NULL’ (default), microdata is assumed.\r\nroundBase\r\nRounding base\r\nhierarchies\r\nList of hierarchies\r\nformula\r\nModel formula defining publishable cells\r\ndimVar\r\nThe main dimensional variables and additional aggregating variables. This parameter can be useful when hierarchies and formula are unspecified.\r\nmaxRound\r\nInner cells contributing to original publishable cells equal to or less than maxRound will be rounded\r\nprintInc\r\nPrinting iteration information to console when TRUE\r\noutput\r\nPossible non-NULL values are ‘“input”’, ‘“inner”’ and ‘“publish”’. Then a single data frame is returned.\r\npreAggregate\r\nWhen ‘TRUE’, the data will be aggregated beforehand within the function by the dimensional variables.\r\n…\r\nFurther parameters sent to ‘RoundViaDummy’\r\n\r\nValues\r\n\r\n\r\n\r\nOutput is a four-element list with class attribute “PLSrounded” (to ensure informative printing).\r\n\r\nItem\r\nDescription\r\ninner\r\nData frame corresponding to input data with the main dimensional variables and with cell frequencies (original, rounded, difference).\r\npublish\r\nData frame of publishable data with the main dimensional variables and with cell frequencies (original, rounded, difference).\r\nmetrics\r\nA named character vector of various statistics calculated from the two output data frames (“‘inner_’” used to distinguish). See examples below and the function ‘HDutility’.\r\nfreqTable\r\nMatrix of frequencies of cell frequencies and absolute differences. For example, row “‘rounded’” and column “‘inn.4+’” is the number of rounded inner cell frequencies greater than or equal to ‘4’.\r\nReferences\r\nLangsrud, Ø. and Heldal, J. (2018): “An Algorithm for Small Count Rounding of Tabular Data”. Presented at: Privacy in statistical databases, Valencia, Spain. September 26-28, 2018. <URL: https://www.researchgate.net/publication/327768398_An_Algorithm_for_Small_Count_Rounding_of_Tabular_Data> See Also: ‘RoundViaDummy’, ‘PLS2way’, ‘ModelMatrix’\r\n\r\nExamples\r\n\r\n\r\n     # Small example data set\r\n     z <- SmallCountData(\"e6\")\r\n     print(z)\r\n     \r\n     # Publishable cells by formula interface\r\n     a <- PLSrounding(z, \"freq\", roundBase = 5,  formula = ~geo + eu + year)\r\n     print(a)\r\n     print(a$inner)\r\n     print(a$publish)\r\n     print(a$metrics)\r\n     print(a$freqTable)\r\n     \r\n     # Recalculation of maxdiff, HDutility, meanAbsDiff and rootMeanSquare\r\n     max(abs(a$publish[, \"difference\"]))\r\n     HDutility(a$publish[, \"original\"], a$publish[, \"rounded\"])\r\n     mean(abs(a$publish[, \"difference\"]))\r\n     sqrt(mean((a$publish[, \"difference\"])^2))\r\n     \r\n     # Six lines below produce equivalent results \r\n     # Ordering of rows can be different\r\n     PLSrounding(z, \"freq\") # All variables except \"freq\" as dimVar  \r\n     PLSrounding(z, \"freq\", dimVar = c(\"geo\", \"eu\", \"year\"))\r\n     PLSrounding(z, \"freq\", formula = ~eu * year + geo * year)\r\n     PLSrounding(z[, -2], \"freq\", hierarchies = SmallCountData(\"eHrc\"))\r\n     PLSrounding(z[, -2], \"freq\", hierarchies = SmallCountData(\"eDimList\"))\r\n     PLSrounding(z[, -2], \"freq\", hierarchies = SmallCountData(\"eDimList\"), formula = ~geo * year)\r\n     \r\n     # Define publishable cells differently by making use of formula interface\r\n     PLSrounding(z, \"freq\", formula = ~eu * year + geo)\r\n     \r\n     # Define publishable cells differently by making use of hierarchy interface\r\n     eHrc2 <- list(geo = c(\"EU\", \"@Portugal\", \"@Spain\", \"Iceland\"), year = c(\"2018\", \"2019\"))\r\n     PLSrounding(z, \"freq\", hierarchies = eHrc2)\r\n     \r\n     # Also possible to combine hierarchies and formula\r\n     PLSrounding(z, \"freq\", hierarchies = SmallCountData(\"eDimList\"), formula = ~geo + year)\r\n     \r\n     # Single data frame output\r\n     PLSroundingInner(z, \"freq\", roundBase = 5, formula = ~geo + eu + year)\r\n     PLSroundingPublish(z, roundBase = 5, formula = ~geo + eu + year)\r\n     \r\n     # Microdata input\r\n     PLSroundingInner(rbind(z, z), roundBase = 5, formula = ~geo + eu + year)\r\n     \r\n     # Parameter avoidHierarchical (see RoundViaDummy and ModelMatrix) \r\n     PLSroundingPublish(z, roundBase = 5, formula = ~geo + eu + year, avoidHierarchical = TRUE)\r\n     \r\n     # Package sdcHierarchies can be used to create hierarchies. \r\n     # The small example code below works if this package is available. \r\n     if (require(sdcHierarchies)) {\r\n       z2 <- cbind(geo = c(\"11\", \"21\", \"22\"), z[, 3:4], stringsAsFactors = FALSE)\r\n       h2 <- list(\r\n         geo = hier_compute(inp = unique(z2$geo), dim_spec = c(1, 1), root = \"Tot\", as = \"df\"),\r\n         year = hier_convert(hier_create(root = \"Total\", nodes = c(\"2018\", \"2019\")), as = \"df\"))\r\n       PLSrounding(z2, \"freq\", hierarchies = h2)\r\n     }\r\n     \r\n     # Use PLS2way to produce tables as in Langsrud and Heldal (2018) and to demonstrate \r\n     # parameters maxRound, zeroCandidates and identifyNew (see RoundViaDummy).   \r\n     # Parameter rndSeed used to ensure same output as in reference.\r\n     exPSD <- SmallCountData(\"exPSD\")\r\n     a <- PLSrounding(exPSD, \"freq\", 5, formula = ~rows + cols, rndSeed=124)\r\n     PLS2way(a, \"original\")  # Table 1\r\n     PLS2way(a)  # Table 2\r\n     a <- PLSrounding(exPSD, \"freq\", 5, formula = ~rows + cols, identifyNew = FALSE, rndSeed=124)\r\n     PLS2way(a)  # Table 3\r\n     a <- PLSrounding(exPSD, \"freq\", 5, formula = ~rows + cols, maxRound = 7)\r\n     PLS2way(a)  # Values in col1 rounded\r\n     a <- PLSrounding(exPSD, \"freq\", 5, formula = ~rows + cols, zeroCandidates = TRUE)\r\n     PLS2way(a)  # (row3, col4): original is 0 and rounded is 5\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-12-07T12:26:03+01:00",
    "input_file": {}
  },
  {
    "path": "posts/protectkostra/",
    "title": "ProtectKostra",
    "description": "Table suppression according to a frequency rule following the standards in the Kostra project.",
    "author": [
      {
        "name": "Kostra",
        "url": {}
      }
    ],
    "date": "2021-12-07",
    "categories": [
      "R",
      "confidentiality"
    ],
    "contents": "\r\n\r\nContents\r\nParameters\r\nValues\r\nExamples\r\n\r\n\r\nGo to source code \r\n\r\nParameters\r\n\r\nItem\r\nDescription\r\ndata\r\nInput data set of class data.frame\r\nidVar\r\nId-variable (name or number)\r\nstrataVar\r\nStrata-variable(s) (name or number)\r\nfreqVar\r\nVariable(s) holding counts (name or number)\r\nfreqVarGroup\r\nNULL (default) or integer representing groups of variables (see details)\r\nprotectZeros\r\nWhen TRUE empty cells (count=0) is considered sensitive\r\nmaxN\r\nAll cells having counts <= maxN are set as primary suppressed\r\nmethod\r\nParameter “method” in ProtectTable: Only “Gauss” possible (only-Gauss replacement function )\r\noutput\r\nOne of “suppressed” (default), “freq”, “sdcStatus” or “extraWide” (only when freqVarGroup is NULL)\r\ntotal\r\nString used to name totals.\r\nsplit\r\nParameter to ‘AutoSplit’ - see varNames and rowData above. When NULL automatic splitting without needing a split string.\r\nsingleTotal\r\nWhen TRUE identical rowsums in all freqVarGroups needed. When FALSE totals for each freqVarGroup will be in output.\r\n…\r\nAdditional variables that will be included in output (name or number).\r\n\r\nValues\r\n\r\n\r\n\r\nA data.frame with as many rows as input\r\n\r\n\r\n\r\nExamples\r\n\r\n\r\n      # ==================================\r\n      #    Examples without freqVarGroup\r\n      # ==================================\r\n     \r\n      # ==== Example 1 , 8 regions ====\r\n      z1w = KostraData(\"z1w\")\r\n      ProtectKostra(z1w,idVar=\"region\",freqVar=2:5)\r\n     \r\n      # ==== Example 2 , 11 regions ====\r\n      z2w <- KostraData(\"z2w\")\r\n      ProtectKostra(z2w,idVar=\"region\",strataVar=c(\"fylke\",\"kostragr\"),freqVar=4:7)\r\n     \r\n      # ==== Example 3 , 36 regions ====\r\n      z3w <- KostraData(\"z3w\")\r\n      ProtectKostra(z3w,idVar=\"region\",strataVar=c(\"fylke\",\"kostragr\"),freqVar=4:15)\r\n     \r\n      #  ==== Example 3b , 36 regions == with three level column name coding\r\n      z3wb <- KostraData(\"z3wb\")\r\n      ProtectKostra(z3wb,idVar=\"region\",strataVar=c(\"fylke\",\"kostragr\"),freqVar=4:15)\r\n     \r\n      #  ==== Example 4 , 437 regions ====\r\n      z4w <- KostraData(\"z4w\")\r\n      ProtectKostra(z4w,idVar=\"region\",strataVar=\"fylke\",freqVar=4:15)\r\n     \r\n      # =====================================================================\r\n      #    Examples with extra variables in output and several id variables\r\n      # =====================================================================\r\n     \r\n      ProtectKostra(z3wb,idVar=\"region\",strataVar=c(\"fylke\",\"kostragr\"),freqVar=4:15,fylke=\"fylke\",kostragr=\"kostragr\")\r\n     \r\n      # Same using DotWrap\r\n      DotWrap(\"ProtectKostra\",dots=c(\"fylke\",\"kostragr\"),z3wb,idVar=\"region\",strataVar=c(\"fylke\",\"kostragr\"),freqVar=4:15)\r\n     \r\n      # Several id variable\r\n      ProtectKostra(z3wb,idVar=c(\"region\",\"fylke\",\"kostragr\"),strataVar=c(\"fylke\",\"kostragr\"),freqVar=4:15,region=\"region\")\r\n     \r\n      # ==================================\r\n      #    Examples with freqVarGroup\r\n      # ==================================\r\n     \r\n      # Generate example data for this function\r\n      exData   <- KostraData(\"z3w\")[,c(1:15,15,4:6)]\r\n      names(exData)[12:19]=c(\"s1\",\"s2\",\"s3\",\"s4\",\"A\",\"B\",\"C\",\"D\")\r\n      exData[,\"s4\"] <- rowSums(exData[,4:11]) - rowSums(exData[,12:14])\r\n     \r\n      # Create input parameter\r\n      freqVarGroup <- c(1,1,1,1,1,1,1,1,2,2,2,2,3,4,-1,5) # Same as c(rep(1,8),rep(2,4),3,4,-1,5)\r\n     \r\n      a <- ProtectKostra(exData ,idVar=\"region\",strataVar=c(\"fylke\",\"kostragr\"),freqVar=4:19,freqVarGroup=freqVarGroup)\r\n      #  Now output of a$C is just missing since \"-1\"\r\n     \r\n      names(exData)[18] <- \"arbeid\" #  Rename from \"C\" to \"arbeid\"\r\n     \r\n      b <- ProtectKostra(exData ,idVar=\"region\",strataVar=c(\"fylke\",\"kostragr\"),freqVar=4:19,freqVarGroup=freqVarGroup)\r\n      # Now \"arbeid\" in output is still between \"B\" and \"D\" as in input. And b$arbeid is NOT just missing\r\n     \r\n      # singleTotal=TRUE\r\n      ProtectKostra(exData ,idVar=\"region\",strataVar=c(\"fylke\",\"kostragr\"),freqVar=4:19,freqVarGroup=freqVarGroup, singleTotal=TRUE)\r\n     \r\n      exData[4,4] <- 3  # Warning will be produced\r\n      ProtectKostra(exData ,idVar=\"region\",strataVar=c(\"fylke\",\"kostragr\"),freqVar=4:19,freqVarGroup=freqVarGroup)\r\n     \r\n      freqVarGroup <- c(11,11,11,11,11,11,11,11,2,2,2,2,3,4,0,5)  # Using this instead give same result in different order\r\n     \r\n     \r\n      # ========================================\r\n      #    Examples with a single freq-variable\r\n      # ========================================\r\n     \r\n      z1w = KostraData(\"z1w\")\r\n      ProtectKostra(z1w,idVar=\"region\",freqVar=2)  # wrong \"name\"\r\n      ProtectKostra(z1w,idVar=\"region\",freqVar=2, freqVarGroup=1) # same name as input\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/protectkostra/../../pictures/protect.jpg",
    "last_modified": "2021-12-07T12:55:18+01:00",
    "input_file": {}
  },
  {
    "path": "posts/protecttable/",
    "title": "ProtectTable",
    "description": "'GaussSuppression', 'protectTable' or 'protect_linked_tables' is run with a data set as the only required input. One (stacked) or several (unstacked) input variables can hold cell counts. 'ProtectTableData' is a tidy wrapper function, which returns a single data frame instead of a list ('info' omitted).",
    "author": [
      {
        "name": "easySdcTable",
        "url": {}
      }
    ],
    "date": "2021-12-07",
    "categories": [
      "R",
      "confidentiality"
    ],
    "contents": "\r\n\r\nContents\r\nParameters\r\nValues\r\nExamples\r\n\r\n\r\nGo to source code \r\n\r\nParameters\r\n\r\nItem\r\nDescription\r\ndata\r\ndata frame\r\ndimVar\r\nThe main dimensional variables and additional aggregating variables (name or number).\r\nfreqVar\r\nVariable(s) holding counts or NULL in the case of micro data (name or number).\r\nprotectZeros\r\nWhen TRUE empty cells (count=0) is considered sensitive (i.e. same as allowZeros in ‘primarySuppression’).\r\nmaxN\r\nAll cells having counts <= maxN are set as primary suppressed.\r\nmethod\r\nParameter ‘method’ in ‘protectTable’, ‘protect_linked_tables’ or wrapper methods via ‘PTwrap’. ‘Gauss’ (default) is an additional method that is not available in sdcTable. • ‘“SIMPLEHEURISTIC”’: This method is default in protectable. • ‘“SIMPLEHEURISTIC_OLD”’: As ‘“SIMPLEHEURISTIC”’ in sdcTable versions prior to 0.32. • ‘“OPT”’, ‘“HITAS”’, ‘“HYPERCUBE”’: Other methods in protectable. ‘“HYPERCUBE”’ is not possible in cases with two linked tables. • ‘“SimpleSingle”’: ‘“SIMPLEHEURISTIC_OLD”’ with ‘detectSingletons=TRUE’ when ‘protectZeros=FALSE’ and ‘“SIMPLEHEURISTIC_OLD”’ with ‘threshold=1’ (can be overridden by input) when ‘protectZeros=TRUE’. • ‘“SIMPLEHEURISTICSingle”’: As ‘“SimpleSingle”’ with ‘“SIMPLEHEURISTIC”’ instead of ‘“SIMPLEHEURISTIC_OLD”’. • ‘“Simple”’: ‘“SIMPLEHEURISTIC_OLD”’ with ‘detectSingletons=FALSE’. • ‘“Gauss”’: ‘GaussSuppression’ is called with parameters ‘x’, ‘candidates’, ‘primary’ and ‘singleton’ automatically generated. Other parameters (‘singletonMethod’, ‘printInc’) can be specified. Alternatively this parameter can be a named list specifying parameters for running tau-argus (see details). See ‘PTwrap’ for other (experimental) wrapper methods (see details).\r\nfindLinked\r\nWhen TRUE, the function may find two linked tables and run protect_linked_tables.\r\ntotal\r\nString used to name totals.\r\naddName\r\nWhen TRUE the variable name is added to the level names, except for variables with most levels.\r\nsep\r\nA character string to separate when addName apply and when creating variable names.\r\nremoveZeros\r\nWhen TRUE, rows with zero count will be removed from the data within the algorithm.\r\ndimList\r\nBy default, hierarchies will be automatically found from data (see ‘FindDimLists’). With non-NULL dimList, these will be changed. In practice this is done by the function ‘ReplaceDimList’.\r\ngroupVarInd\r\nPossible manual specification of list defining the hierarchical variable groups. When NULL (default) this information will be found automatically by ‘FindTableGroup’.\r\nind1\r\nCoding of table 1 as indices referring to elements of groupVarInd. This information will be found automatically by ‘FindTableGroup’ when groupVarInd=NULL.\r\nind2\r\nCoding of table 2 as indices referring to elements of groupVarInd (as ind1 above).\r\nrowData\r\nInput to ‘Stack’ used to generate extra dimVar variables when stacking in cases with several freqvar variables. When NULL rowData will be created automatically by ‘AutoSplit’ using varNames (see below) and the the freqvar names as input.\r\nvarNames\r\nThe names of the extra dimVar variable(s) made when stacking in cases with several freqvar variables. When length(varNames)>1 several variables may be found by ‘AutoSplit’.\r\nsplit\r\nParameter to ‘AutoSplit’ - see varNames and rowData above. When NULL (default), automatic splitting without needing a split string.\r\nborder\r\nParameter to ‘AutoSplit’ - see varNames and rowData above.\r\nrevBorder\r\nParameter to ‘AutoSplit’ - see varNames and rowData above..\r\nfreqName\r\nInput to ‘Stack’. The name of the new freqvar variable obtained when stacking in cases with several input freqvar variables.\r\ntotalFirst\r\nParameter controlling how output is sorted.\r\nnumericOrder\r\nParameter controlling how output is sorted. Output is character but sorting can be based on the numeric input variables.\r\nnamesAsInput\r\nWhen TRUE those output variables (created by unstacking) that correspond to input will be named as input.\r\norderAsInput\r\nWhen TRUE output corresponding to input will be ordered as input and kept together as one block.\r\nsortByReversedColumns\r\nWhen TRUE output will be sorted by variables in opposite order.\r\ndoUnstack\r\nWhen FALSE output will not be unstacked (in cases with sever input freqvar variables)\r\nremoveTotal\r\nWhen TRUE the total string (see total above) will be removed from the names of output variables created by unstacking (in cases with sever input freqvar variables).\r\nsingleOutput\r\nWhen TRUE output will be in as single data set. Default is FALSE for unstacked data (in cases with sever input freqvar variables) and otherwise TRUE.\r\nsuppression\r\nValue used for suppressed elements in suppressed output data. Default is NA.\r\noutFreq\r\nString used to name output variable(s)\r\noutSdcStatus\r\nString used to name output variable(s)\r\noutSuppressed\r\nString used to name output variable(s)\r\ninfoAsFrame\r\nWhen TRUE output element info is a data frame (useful in Shiny).\r\nIncProgress\r\nA function to report progress (incProgress in Shiny). Set equal to NULL to turn it off.\r\nverbose\r\nParameter sent to ‘protectTable’, ‘protect_linked_tables’ or ‘runArgusBatchFile’.\r\n…\r\nFurther parameters sent to ‘protectTable’ (possibly via ‘protect_linked_tables’) such as solve_attackerprobs and timeLimit. Parameters to ‘GaussSuppression’, ‘createArgusInput’ and ‘PTwrap’ is also possible (see details).\r\n\r\nValues\r\n\r\n\r\n\r\nWhen singleOutput=TRUE output is a list of two elements. • ‘info’: Information as a single column character matrix. This is information about the extra dimVar variables created when stacking, information about the identified (linked) table(s) and summary output from sdcTable. With ‘method=“Gauss”’, a sdcTable function is run with ‘maxN=0’ to create a template for the real output. Some of the summary info is therefore misleading in this case. • ‘data’: A data frame where variables are named according to outFreq, outSdcStatus and outSuppressed. When singleOutput=FALSE output element data is replaced by three elements and these are named according to outFreq, outSdcStatus and outSuppressed.\r\n\r\n\r\n\r\nExamples\r\n\r\n\r\n      # ==== Example 1 , 8 regions ====\r\n      z1 <- EasyData(\"z1\")        \r\n      ProtectTable(z1,1:2, 3)\r\n      ProtectTableData(z1,1:2, 3)\r\n      ProtectTable(z1, c(\"region\",\"hovedint\"), \"ant\") # Input by name \r\n      # --- Unstacked input data ---\r\n      z1w = EasyData(\"z1w\") \r\n      ProtectTable(z1w, 1, 2:5)\r\n      ProtectTableData(z1w, 1, 2:5)\r\n      ProtectTable(z1w, 1, 2:5, varName=\"hovedint\") \r\n      ProtectTable(z1w, 1, 2:5, method=\"HITAS\")\r\n      ProtectTable(z1w, 1, 2:5, totalFirst = TRUE, method =\"Simple\")\r\n      \r\n      # ==== Example 2 , 11 regions ====\r\n      z2 <- EasyData(\"z2\") \r\n      ProtectTable(z2,c(1,3,4), 5) # With region-variable kostragr\r\n      # --- Unstacked input data ---\r\n      z2w <- EasyData(\"z2w\") \r\n      ProtectTable(z2w, 1:2, 4:7) # With region-variable fylke\r\n      ProtectTable(z2w, 1:3, 4:7) # Two linked tables\r\n      \r\n      ## Not run:\r\n     \r\n      # ==== Example 3 , 36 regions ====\r\n      z3 <- EasyData(\"z3\")   \r\n      ProtectTable(z3, c(1,4,5), 7)                               # Three dimensions. No subtotals    \r\n      ProtectTable(z3, 1:6, 7)                                    # Two linked tables  \r\n      # --- Unstacked input data with coded column names \r\n      z3w <- EasyData(\"z3w\")\r\n      ProtectTable(z3w,1:3,4:15, varName=\"g12\")                   # coding not used when single varName\r\n      ProtectTable(z3w,1:3,4:15, varName=c(\"hovedint\",\"mnd\"))     # Two variables found automatically \r\n      ProtectTable(z3w,1:3,4:15, varName=c(\"hovedint\",\"mnd\"),\r\n                    removeTotal=FALSE)                            # Keep \"Total\" in variable names \r\n      # --- Unstacked input data with three level column name coding\r\n      z3wb <- EasyData(\"z3wb\")  \r\n      ProtectTable(z3wb,1:3,4:15,varName=c(\"hovedint\",\"mnd\",\"mnd2\")) # Two variables found automatically\r\n      ProtectTable(z3wb,1:3,4:15,varName=c(\"hovedint\",\"mnd\",\"mnd2\"), \r\n                  split=\"_\")                                         # Three variables when splitting\r\n      ProtectTable(z3wb,1:3,4:15,varName=c(\"hovedint\",\"mnd\",\"mnd2\"),\r\n                    split=\"_\",namesAsInput=FALSE,orderAsInput=FALSE) # Alternative ouput format\r\n                    \r\n      # ====  Examples Tau-Argus ====              \r\n      exeArgus <- \"C:/TauArgus4.1.4/TauArgus.exe\" # Change to TauArgus.exe-path in your computer\r\n      pathArgus <- \"C:/Users/nnn/Documents\"       # Change to an existing folder \r\n      z1 = EasyData(\"z1\") \r\n      ProtectTable(z1,1:2,3,method=list(exe=exeArgus, path=pathArgus, typ=\"tabular\", method=\"OPT\")) \r\n      ProtectTable(z1,1:2,3,method=list(exe=exeArgus, path=pathArgus, typ=\"tabular\", method=\"MOD\")) \r\n      ProtectTable(z1,1:2,3,method=list(exe=exeArgus, path=pathArgus, typ=\"tabular\", method=\"GH\"))\r\n       ProtectTable(z1,1:2,3,maxN=-1,\r\n        method=list(path=pathArgus, exe=exeArgus, method=\"OPT\",\r\n              primSuppRules= list(list(type=\"freq\", n=4, rg=20))))\r\n      z3 <- EasyData(\"z3\")\r\n      ProtectTable(z3,c(1:2,4,5),7,maxN=-1,\r\n        method=list(path=pathArgus, exe=exeArgus, method=\"OPT\",\r\n              primSuppRules=list(list(type=\"freq\", n=4, rg=20))))\r\n              \r\n                    \r\n     # ==== Examples with parameter dimList  ====\r\n     z2 <- EasyData(\"z2\")\r\n     dList <- FindDimLists(z2[-5])\r\n     ProtectTable(z2[, c(1,4,5)], 1:2, 3, dimList = dList[c(1,3)])\r\n     ProtectTable(z2[, c(1,4,5)], 1:2, 3, dimList = dList[2])\r\n     ProtectTable(z2[, c(1,4,5)], 1:2, 3, dimList = DimList2Hrc(dList[c(2,3)]))\r\n     ## End(Not run)\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/protecttable/../../pictures/protect2.jpg",
    "last_modified": "2021-12-07T12:55:44+01:00",
    "input_file": {}
  },
  {
    "path": "posts/applyklass/",
    "title": "ApplyKlass",
    "description": "Apply a classification to a variable.",
    "author": [
      {
        "name": "klassR",
        "url": "http://github.com/statisticsnorway/klassR"
      }
    ],
    "date": "2021-11-25",
    "categories": [
      "R",
      "dataediting",
      "classification"
    ],
    "contents": "\r\n\r\nContents\r\n1. Retrieving classification name\r\n2. Language\r\n3. Change level\r\n4. More help\r\n\r\nApplyKlass is designed to provide an easy interface to applying classifications from Statistic Norway’s classification database. It can be used on a vector.\r\nSee https://www.ssb.no/klass/ for details on Statistic Norway’s classifications and codelists.\r\n\r\n\r\n\r\n1. Retrieving classification name\r\nApplyKlass can be used to retreive the name of a classification vector.\r\n\r\n\r\nlibrary(klassR)\r\ndt <- data.frame(orgnr = c(324833,95765, 32732),\r\n                 naering = c(\"01\", \"05\", \"06\"))\r\ndt$naering_name <- ApplyKlass(dt$naering, klass = 6)\r\ndt\r\n\r\n\r\n\r\n\r\norgnr\r\nnaering\r\nnaering_name\r\n324833\r\n01\r\nJordbruk og tjenester tilknyttet jordbruk, jakt og viltstell\r\n95765\r\n05\r\nBryting av steinkull og brunkull\r\n32732\r\n06\r\nUtvinning av råolje og naturgass\r\n\r\n2. Language\r\nDifferent languages can be fetched out. These are coded “nn” for nynorsk, “nb” for bokmål and “en” for English.\r\n\r\n\r\ndt$naering_name <- ApplyKlass(dt$naering, klass = 6, language = \"en\")\r\ndt\r\n\r\n\r\n\r\n\r\norgnr\r\nnaering\r\nnaering_name\r\n324833\r\n01\r\nCrop and animal production, hunting and related service activities\r\n95765\r\n05\r\nMining of coal and lignite\r\n32732\r\n06\r\nExtraction of crude petroleum and natural gas\r\n\r\n3. Change level\r\nSometimes a different level is desired. In this case we specify using the output_level parameter.\r\n\r\n\r\ndt$hoved_naering <- ApplyKlass(dt$naering, \r\n                               klass = 6,\r\n                               output_level = 1,\r\n                               output = \"code\")\r\ndt\r\n\r\n\r\n\r\n\r\norgnr\r\nnaering\r\nnaering_name\r\nhoved_naering\r\n324833\r\n01\r\nCrop and animal production, hunting and related service activities\r\nA\r\n95765\r\n05\r\nMining of coal and lignite\r\nB\r\n32732\r\n06\r\nExtraction of crude petroleum and natural gas\r\nB\r\n\r\n4. More help\r\nSee https://www.ssb.no/klass/ for details on Statistic Norway’s classifications and codelist.\r\n\r\n\r\n\r\n",
    "preview": "posts/applyklass/../../pictures/klass.png",
    "last_modified": "2021-12-07T11:21:21+01:00",
    "input_file": {},
    "preview_width": 908,
    "preview_height": 589
  },
  {
    "path": "posts/hierarchycompute/",
    "title": "HierarchyCompute",
    "description": "This function computes aggregates by crossing several hierarchical specifications and factorial variables.",
    "author": [
      {
        "name": "SSBtools",
        "url": "https://cran.r-project.org/web/packages/SSBtools/index.html"
      }
    ],
    "date": "2021-11-25",
    "categories": [
      "R",
      "confidentiality"
    ],
    "contents": "\r\n\r\n\r\nlibrary(SSBtools)\r\n\r\n# Data and hierarchies used in the examples\r\nx <- SSBtoolsData(\"sprt_emp\") # Employment in sport in thousand persons from Eurostat database\r\ngeoHier <- SSBtoolsData(\"sprt_emp_geoHier\")\r\nageHier <- SSBtoolsData(\"sprt_emp_ageHier\")\r\n# Two hierarchies and year as rowFactor\r\nHierarchyCompute(x, list(age = ageHier, geo = geoHier, year = \"rowFactor\"), \"ths_per\")\r\n\r\n\r\n     age    geo year ths_per\r\n1 Y15-64 Europe 2014   222.3\r\n2 Y15-64  nonEU 2014     3.3\r\n3 Y15-64     EU 2014   219.0\r\n4 Y15-64 Europe 2015   225.0\r\n5 Y15-64  nonEU 2015     3.5\r\n6 Y15-64     EU 2015   221.5\r\n7 Y15-64 Europe 2016   233.5\r\n8 Y15-64  nonEU 2016     3.8\r\n9 Y15-64     EU 2016   229.7\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/hierarchycompute/../../pictures/heirarchy.png",
    "last_modified": "2021-12-07T12:54:36+01:00",
    "input_file": {},
    "preview_width": 717,
    "preview_height": 402
  },
  {
    "path": "posts/lmimpute/",
    "title": "LmImpute",
    "description": "Imputation by weighted regeression, using lm, allowing multiple explanatory variables and multiple response variables. Impute missing and wrong values (category 3) by the model based on representative data (category 1). Some data are considered correct but not representative (category 2).",
    "author": [
      {
        "name": "Kostra",
        "url": "https://github.com/statisticsnorway/Kostra"
      }
    ],
    "date": "2021-11-24",
    "categories": [
      "R",
      "dataediting",
      "imputation"
    ],
    "contents": "\r\n\r\nContents\r\n1. Arguments\r\n2. Value\r\n3. Examples\r\n\r\n\r\nGo to source code \r\n\r\n1. Arguments\r\n\r\nItem\r\nDescription\r\ndata\r\nInput data set (data.frame, data.table or list)\r\nmodel\r\nString with model formula\r\nweights\r\nNULL or string with weight expression\r\nlimitModel\r\nStudentized residuals limit. Above limit -> category 2.\r\nlimitIterate\r\nStudentized residuals limit for iterative calculation of studentized residuals.\r\nlimitImpute\r\nStudentized residuals limit. Above limit -> category 3. No imputation when 0.\r\nmaxiter\r\nMaximum number of iterations.\r\nreturnIter\r\nWhen TRUE, iteration when observation was thrown outin output.\r\nreturnYHat\r\nWhen TRUE, fitted values and corresponding estimates in output.\r\nreturnFirst\r\nWhen TRUE, studentized residuals from first iteration in output.\r\nreturnLast\r\nWhen TRUE, some results from last iteration in output.\r\nreturnFinal\r\nWhen TRUE, extra results from final model in output.\r\nMultiFuction\r\nTransforming rStud for several responses into a single positive value.\r\nestimationGroup\r\nTotal estimates will be be computed within each group. Default (and TRUE) is a single group (estimationGroup <- rep(1, N) ).\r\nunfoldCoef\r\nWhen TRUE several elements of coef will be spilt as several ouput elements. unfoldCoef=2 is a specialised variant used to ensure two coefficients in output (extra coefficient zero).\r\ncategory123\r\nWhen non-NULL, this is used directly with no iteration.\r\nforceCategory2\r\nForce category 2 (can be useful for elements imputed by another method)\r\nBackTransform\r\nWhen model contains transformation of y (e.g: “log(y)~x”) a function (e.g: exp) can be supplied to transform back to original scale before calculation of leaveOutResid, yHat, yImputed, estimate, estimateYHat, estimateOrig and seRobust.\r\nwarningEstimate\r\nWarning text when missing values. Use NULL to avoid warning.\r\nremoveEmpty\r\nWhen TRUE empty elements will be removed from output.\r\nNArStudHandling\r\nFunction (warning or stop) taking a message as input. Used when rStud in model (category 1) is missing.\r\ncvPercent\r\nWhen TRUE (default) cv output is in percent\r\nreturnSameType\r\nWhen TRUE and when the type of input y variable(s) is integer, the output type of yImputed and estimate is also integer. Estimates/sums are then calculated from rounded imputed values.\r\n\r\n2. Value\r\n\r\n\r\n\r\nA list with separate elements. Each element can be a scalar, vector or a matrix. Possible elements are:\r\n\r\nItem\r\nDescription\r\nx\r\nThe input x variable\r\ny\r\nThe input y variable\r\nstrata\r\nThe input strata variable\r\ncategory123\r\nThe three imputation groups: representative (1), correct but not representative (2), wrong (3) and zero when x is missing.\r\nyHat\r\nFitted values\r\nyImputed\r\nImputed y-data\r\nrStudFirst\r\nInitial studentized residuals\r\nrStud\r\nThe final (or last) studentized residuals\r\ndffits\r\nThe final (or last) DFFITS statistic\r\nhii\r\nThe final (or last) leverages (diagonal elements of hat matrix)\r\nleaveOutResid\r\nThe final (or last) outside-model residual\r\niter\r\nIteration when observation was thrown out\r\nN\r\nTotal number of observations (rows in data)\r\nnImputed\r\nNumber of imputed observations\r\nestimate\r\nTotale estimate from imputed data\r\ncv\r\nCoefficient of variation = seEstimate/estimate. In percent when cvPercent=TRUE (default)\r\nestimateYhat\r\nTotale estimate based on model fits\r\nestimateOrig\r\nEstimate based on original data with missing set to zero\r\ncoef\r\nThe final (or last) model coefficient(s). Several variables when several parameters (“coef..Intercept.”, “coef.x”).\r\nnModel\r\nThe final (or last) number of observations in model.\r\nsigmaFirst\r\nInitial square root of the estimated variance parameter\r\nsigmaHat\r\nThe final (or last) square root of the estimated variance parameter\r\nseEstimate\r\nThe final (or last) standard error estimate of the total estimate from imputed data\r\nseRobust\r\nRobust variant of seEstimate (experimental)\r\n\r\n3. Examples\r\n\r\n\r\n     z = data.frame(  # Same example as in Thorud et.al (2010).\r\n             x = c(1.1, 2.2, 3.3, 4.4, 5.5),\r\n             y = c(2.3, 3.1, 3.2, 3.7, 4.5))\r\n     LmImpute(z)  # Simple regression\r\n     LmImpute(z, model = \"y~x-1\", weights = \"1/x\")  # Ratio model\r\n     \r\n     rateData <- KostraData(\"rateData\")               # Real Kostra data set\r\n     w <- rateData$data[, c(16, 5, 14, 15, 19)]\r\n     w <- w[is.finite(w[,\"Ny.kostragruppe\"]), ]       # Remove Longyearbyen\r\n     w[w[,\"Ny.kostragruppe\"]>13,\"Ny.kostragruppe\"]=13 # Combine small strata\r\n     names(w) = c(\"x\", \"y\", \"y14\", \"y15\", \"k\")\r\n     \r\n     # Ratio model within each strata assumming common variance\r\n     LmImpute(w, \"y~x:factor(k)-1\", weights = \"1/x\", estimationGroup = w$k)\r\n     \r\n     # Similar to above, but two y variables\r\n     LmImpute(w, \"cbind(y14,y15)~x:factor(k)-1\", weights = \"1/x\", estimationGroup = w$k)\r\n     \r\n     # Using transformation and \"BackTransform\"\r\n     LmImpute(w, \"sqrt(y)~x\",BackTransform = function(x) x^2,returnYHat = TRUE)\r\n     \r\n     # Direct imputation of x\r\n     LmImpute(w, \"I(y-x)~0\",weights = \"1/x\",\r\n       BackTransform = function(y){return(y+dynGet(\"data\")$x)},\r\n       limitModel = Inf, limitIterate = Inf, limitImpute = Inf,\r\n       returnYHat = TRUE)\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/lmimpute/../../pictures/regression.png",
    "last_modified": "2021-12-07T11:22:01+01:00",
    "input_file": {},
    "preview_width": 480,
    "preview_height": 480
  }
]
